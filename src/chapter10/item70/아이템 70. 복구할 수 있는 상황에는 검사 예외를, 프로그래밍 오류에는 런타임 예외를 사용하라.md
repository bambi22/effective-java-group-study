# 💡 자바 예외
![image](https://github.com/shin-je-woo/effective-java-group-study/assets/39439576/68838ec1-baaa-49ba-a18e-00e0830eec95)
* `Object` : 예외도 객체이다. 모든 객체의 최상위 부모는 Object 이므로 예외의 최상위 부모도 Object이다.
* `Throwable` : 최상위 예외이다. 하위에 Exception 과 Error 가 있다.
* `Error` : 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 예외이다. 
  * 애플리케이션 개발자는 이 예외를 잡으려고 해서는 안된다.
  * 상위 예외를 catch 로 잡으면 그 하위 예외까지 잡기 때문에 Throwable 예외도 잡으면 안된다. (Error 예외도 함께 잡을 수 있기 때문이다.)
  * 애플리케이션 로직은 이런 이유로 Exception 부터 필요한 예외로 생각하고 잡으면 된다. 참고로 Error 도 언체크 예외이다.
* `Exception` : 체크 예외
  * 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외이다.
  * Exception 과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다. 단 RuntimeException 은 예외로 한다.
* `RuntimeException` : 언체크 예외, 런타임 예외
  * 컴파일러가 체크 하지 않는 언체크 예외이다.
  * RuntimeException 과 그 자식 예외는 모두 언체크 예외이다.
  * RuntimeException 의 이름을 따라서 RuntimeException 과 그 하위 언체크 예외를 런타임 예외라고 많이 부른다.
 
## 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
- 복구 가능한 경우라면 검사 예외를 사용할 것.
- 검사 예외를 던지면 호출자가 예외를 catch로 잡거나 바깥으로 전파하도록 강제하게 된다.
- 여기서 전파란 메서드 선언부에 throws를 다는 것
- 즉, 검사예외를 던진다는 것은 클라이언트쪽에서 그 상황에 대처할 수 있도록 힌트를 주는 것
- 반면, 런타임 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다 실이 많다는 뜻
- (웹 애플리케이션에서는 조금 다른 듯? 복구의 의미보다 RuntimeException을 던지고 ExceptionHandler에서 특정 API포맷으로 응답하는 경우도 있음)

## 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
- 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.
- 예를 들어 배열의 인덱스는 `0 ~ 배열 크기-1` 이어야 한다는 전제조건이 있다.
- 이를 어기면 `ArrayIndexOutOfBoundsException`이 발생하는데, 이는 전제조건을 지키지 않았다는 뜻이다.(런타임 예외임)

## 위 두가지를 확신할 수 없는 경우라면?
- 예를 들어 자원 고갈은 말도 안되는 크기의 배열을 할당해 생긴 프로그래밍 오류일 수도 있고(런타임 오류)
- 자원이 일시적으로 부족하거나 수요가 순간적으로 몰린 것이라면 충분히 복구할 수 있다.(체크 예외)
- 이 경우에는 클라이언트 입장에서 생각하자.
- 클라이언트가 복구할 기회가 있다면 체크 예외를, 그 외의 경우라면 언체크 예외를 던지는 것이 나은 판단이다.

## Error클래스는?
- 에러는 보통 JVM이 자원 부족, 불변식 걔짐 등 더 이상 수행할 수 없는 상황을 나타낼 때 사용한다.
- 자바 언어 명세가 요구하는 것은 아니지만 업계에 널리 퍼진 규약이므로 Error 클래스를 상속해 하위 클래스를 만들지 말자!
- 우리가 구현하는 언체크 예외는 `RuntimeException` 의 하위 클래스여야 한다.
- 마찬가지로 throwable도 직접 사용하지 말자.
